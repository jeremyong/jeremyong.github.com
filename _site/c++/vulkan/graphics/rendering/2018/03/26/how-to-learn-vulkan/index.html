<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>How to Learn Vulkan &#8211; ninepoints</title>
  <meta name="viewport" content="width=device-width">
  <meta name="description"
    content="C++, graphics, deep learning, multithreading, Vulkan, OpenGL, DirectX, Math, compilers, and more">
  
  <meta name="robots" content="all">
  <meta name="author" content="Jeremy Ong">
  <link rel="canonical" href="https://jeremyong.com/c++/vulkan/graphics/rendering/2018/03/26/how-to-learn-vulkan/">
  <link rel="alternate" type="application/rss+xml" title="RSS Feed for ninepoints" href="/%20/feed.xml" />

  <!-- Custom CSS -->
  <link rel="stylesheet" href="/css/main.css" type="text/css">

  <!-- Fonts -->
  
  <link href="https:////maxcdn.bootstrapcdn.com/font-awesome/latest/css/font-awesome.min.css" rel="stylesheet">
  

  
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css"
    integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">

  <!-- The loading of KaTeX is deferred to speed up page rendering -->
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js"
    integrity="sha384-g7c+Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI+sEnkvrMWph2EDg4"
    crossorigin="anonymous"></script>

  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js"
    integrity="sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC+Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa" crossorigin="anonymous"
    onload="renderMathInElement(document.body);"></script>
  

  <!-- Icons -->
  <link rel="apple-touch-icon" sizes="57x57" href="/apple-touch-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/apple-touch-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/apple-touch-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/apple-touch-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/apple-touch-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/apple-touch-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/apple-touch-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/apple-touch-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon-180x180.png">
  <link rel="icon" type="image/png" href="/favicon-192x192.png' sizes=" 192x192">
  <link rel="icon" type="image/png" href="/favicon-160x160.png' sizes=" 160x160">
  <link rel="icon" type="image/png" href="/favicon-96x96.png' sizes=" 96x96">
  <link rel="icon" type="image/png" href="/favicon-16x16.png' sizes=" 16x16">
  <link rel="icon" type="image/png" href="/favicon-32x32.png' sizes=" 32x32">
  <link rel="shortcut icon" href="/favicon.ico">

  <script>
    if (window.navigator && navigator.serviceWorker) {
      navigator.serviceWorker.getRegistrations()
        .then(function (registrations) {
          for (let registration of registrations) {
            registration.unregister();
          }
        });
    }
  </script>
  
  <script async type="text/javascript">
    (function (i, s, o, g, r, a, m) {
      i['GoogleAnalyticsObject'] = r; i[r] = i[r] || function () {
        (i[r].q = i[r].q || []).push(arguments)
      }, i[r].l = 1 * new Date(); a = s.createElement(o),
        m = s.getElementsByTagName(o)[0]; a.async = 1; a.src = g; m.parentNode.insertBefore(a, m)
    })(window, document, 'script', 'https://www.google-analytics.com/analytics.js', 'ga');
    ga('create', 'UA-10576233-1', 'auto');
    ga('send', 'pageview');
  </script>
  
</head>

<body>
  <div class="content">
    <nav class="nav">
  
  

  <ul class="wrap">
    <li>
      <a href="/" class="site-title">Home</a>
    </li>
    

    

    <li>
      
      <a href="/about/">About</a>
      
    </li>


    

    

    <li>
      
    </li>


    
    <li>
      <a class="fa fa-github" href="https://github.com/jeremyong"></a>
    </li>
    <li>
      <a class="fa fa-twitter" href="https://twitter.com/m_ninepoints"></a>
    </li>
    <li>
      <a class="fa fa-linkedin" href="https://www.linkedin.com/in/jeremycong"></a>
    </li>
  </ul>
</nav>

    <div class="wrap">
      <div class="front-matter">
  <div class="wrap">
    <h1>How to Learn Vulkan</h1>
    <h2></h2>
    <div class="byline">
      <p>26 March 2018</p>
    </div>
    <div class='clear'></div>
  </div>
</div>

<div class="wrap article">
  <p>This blog post is a meta post on the general act of going through the motions in learning Vulkan, and outlines what is hopefully an effective strategy for newer practicitioners. I’ll do my best to outline major pitfalls that I encountered on my own, and where I recommend spending the bulk of your time, as well as a rough “timeline.” For people already familiar with OpenGL and DirectX, I hope to also explain in plain terms what functionality you were relying on the driver for previous that you are now responsible for (and what that means). I’m <em>not</em> going to try to explain how to solve each one of the problems you will encounter, as this post will get unbearably long as to not serve any real purpose. I <em>will</em> endeavor to provide links to good resources in the community already <em>and</em> explain how to read/utilize them. This blog post is meant to be read/skimmed once, and then bookmarked for reference as you proceed with your journey. If there were resources you think I missed that you think may be worth including, feel free to tweet me (twitter link at the bottom of this page)! So without further ado…</p>

<h1 id="assumptions">Assumptions</h1>

<p>First, some quick assumptions. I’m going to assume you use C or C++. I’m going to assume you’ve worked with Direct3D (aka DirectX) or OpenGL before, but not necessarily Direct3D 12 or Metal. I’m going to assume you are interested in learning Vulkan because you heard it performs better, because you want a more viable cross-platform solution (especially now that MoltenSDK is open sourced), or because you like learning shiny things (hey, who doesn’t). I’m also going to assume you’ve done multithreaded programming before (you know what a mutex is, and you’ve dealt with race conditions and deadlocks). At least the basics.</p>

<h4 id="a-quick-note-for-people-with-0-graphics-experience-or-opengldirect3d-experience">A quick note for people with 0 graphics experience or OpenGL/Direct3D experience</h4>

<p>Would I recommend Vulkan for such people? Probably not. There are other blogposts that recommend the contrary, and this is entirely subjective, but in such a case, I believe true beginners in graphics are much more likely to get frustrated programming in Vulkan, not knowing what they are aiming for. Vulkan is less about graphics, and more about GPU drivers at its core, meaning that if your primary goal is understanding how a cascaded shadow map works, or how indirect lighting is done, or screen-space-reflections, you gain nothing by using Vulkan.</p>

<p>Exceptions to the above caveat are people who are convinced they want to do this professionally, in which case a holistic understanding can only help you (although I still strongly recommend learning Vulkan in parallel with running experiments using simpler APIs). Also, people that have masochistic tendencies and/or have a very strong abstraction muscle in their brain will not find too much difficulty. Vulkan is very broad and deep but it is logical. Engineers that don’t find themselves struggling when jumping into a very large codebase for the first time will similarly not find too many difficulties here.</p>

<h4 id="a-quick-note-for-people-who-arent-cc-programmers-and-want-to-use-vulkan">A quick note for people who aren’t C/C++ programmers and want to use Vulkan</h4>

<p>I generally advise against this, if only because lower-level explicit control means more foreign-function calls into C-land. For languages that are interpreted languages (excluding Rust, for example), the overhead of the extra function calls will add up and potentially offset the performance gains you may have realized with Vulkan in the first place. This is likely why something like Vulkan is unsuitable as a basis for any future <code class="language-plaintext highlighter-rouge">WebGL</code> efforts, but don’t quote me on this.</p>

<h1 id="viable-learning-mentality">Viable Learning Mentality</h1>

<p>First, a few words on the mentality I recommend when approaching Vulkan. You probably already have a good degree of apprehension to learning it, or maybe you’ve attempted to learn Vulkan before and gave up half-way through. Alternatively, you may have gone through a few tutorials but still feel a bit shaky on concepts that are still in the realm of “black magic.” I have a few recommendations on how to adjust your mentality to best maximize your chance for success.</p>

<h4 id="do-not-assume-you-arent-making-progress-if-you-arent-making-visible-progress">Do not assume you aren’t making progress if you aren’t making <em>visible</em> progress</h4>

<p>As graphics engineers, we’re used to getting a triangle on screen relatively quickly, and go from there (xform matrices, texture sampling, some simple lighting, and <strong>bam</strong> graphics engine). Most new Vulkan users that have already tried a tutorial or two will likely encounter this mental roadblock and find themselves asking, “why can’t I see anything yet!” and get frustrated. Better is to take notes and tally up what you <em>have</em> done. For example:</p>

<ul>
  <li>I can create a logical representation of the device</li>
  <li>I can create a swapchain</li>
  <li>I can allocate memory on the GPU</li>
  <li>I can express that this chunk of memory in this region should be interpreted as an image in this layout</li>
</ul>

<p>With Vulkan, you won’t be “drawing” things as much as being extremely explicit about all the state necessary for the simple <code class="language-plaintext highlighter-rouge">draw</code> command at the end to consume all that state and perform its magic. Don’t be discouraged if getting to this <code class="language-plaintext highlighter-rouge">draw</code> takes 5 to 10 times longer than you’re used to! Vulkan does not provide “sensible defaults” and makes absolutely zero assumptions about what you as the programmer intends on doing. This is, of course, to bolster performance, as everything is opt-in.</p>

<h4 id="you-will-forget-why-you-did-things-or-how-something-works-as-you-learn-more">You will forget why you did things, or how something works as you learn more</h4>

<p>Even for engineers with excellent memory and recall capabilities, you will likely need to constantly backtrack and review why something was necessary or how something was done. The graphics pipeline is extremely deep, and it’s easy to lose the big picture once you get stuck in the weeds. The best way to combat this is to proactively pause and remind yourself what you have done and accomplished in order to get to where you currently are. This is especially difficult in the very beginning as a lot of the concepts are orthogonal and have no interdependency. It will be easy to get caught up asking “does X actually need to happen before Y.” This is pretty normal also, so just know to expect it and do your best to capture in notes what’s going on in broad phases.</p>

<h4 id="expect-that-there-are-tons-of-ways-to-do-the-same-thing-and-that-experts-havent-necessarily-settled-on-the-best-ways">Expect that there are tons of ways to do the same thing, and that experts haven’t necessarily settled on the best ways</h4>

<p>With more explicit control, developers in Vulkan have a ton of freedom in expressing how a thing should be drawn (or computation performed). Many different resources will take different approaches, and without understanding the fundamentals, you will not understand what tradeoffs are being made. Keep in mind also that many existing frameworks and engines <em>ported</em> existing functionality to Vulkan, so occasionally, they make abstraction choices to be compatibile with Vulkan. <em>These decisions are not necessarily optimal!</em> I can’t emphasize enough how much you must attempt to learn the mental model yourself, or you may find yourself an expert in a super verbose version of OpenGL.</p>

<h4 id="you-should-refer-to-the-spec-early-and-often">You should refer to the spec early and often</h4>

<p>It is never to early to refer to the <a href="https://www.khronos.org/registry/vulkan/specs/1.1/html/vkspec.html">spec</a>. When you download the SDK, this is included in the <code class="language-plaintext highlighter-rouge">docs</code> folder so just bookmark it in your browser to access it quickly. If you haven’t done this yet, do it now! You want accessing this to be as low-cost as possible to train yourself to refer to it. I recommend accessing it as you encounter new concepts or Vulkan types (in other words, treat it as a reference). Many sections feel “dry” but compared to reference documentation for other APIs or programming languages, I have found the density of useful information in the Vulkan specification to be quite high and well worth the time invested.</p>

<h1 id="preliminaries">Preliminaries</h1>

<ul>
  <li>Remind yourself how the graphics pipeline works
    <ul>
      <li><a href="https://fgiesen.wordpress.com/2011/07/09/a-trip-through-the-graphics-pipeline-2011-index">Trip through the graphics pipeline</a>: An excellent must-read tour through the graphics pipeline</li>
      <li>The graphics rendering pipeline chapter in <a href="http://www.realtimerendering.com">Real Time Rendering</a> (note: if you don’t already have this book, hold off on buying it as the 4th edition is coming out soon!)</li>
    </ul>
  </li>
  <li>Read <a href="https://renderdoc.org/vulkan-in-30-minutes.html">Vulkan in 30 minutes</a> by baldurk (author of renderdoc, a must-have tool for gfx debugging)
    <ul>
      <li>Try to map the concepts mentioned in this article to your understanding of the graphics pipeline</li>
    </ul>
  </li>
  <li>Install all the things!
    <ul>
      <li>Latest <a href="https://vulkan.lunarg.com/sdk/home">VulkanSDK</a> (run vulkaninfo to convince yourself you have a compatible gfx card and driver)</li>
      <li><a href="https://renderdoc.org">RenderDoc</a></li>
      <li>If it’s your cup of tea, you can also get nVidia nsight or Radeon GPU Profiler (RGP) for perf testing (but I don’t believe this is necessary for learning at all)</li>
    </ul>
  </li>
  <li>Bookmark all the things. You’ll be referring to these a LOT so save those clicks
    <ul>
      <li><a href="https://software.intel.com/en-us/articles/api-without-secrets-introduction-to-vulkan-part-1">API without Secrets</a>: Intel’s excellent “Hello, world” tutorial with a healthy amount of background information</li>
      <li><a href="https://vulkan-tutorial.com">Vulkan Tutorial</a>: Another great Vulkan “Hello, world”</li>
      <li><a href="https://www.khronos.org/registry/vulkan/specs/1.1/html/vkspec.html">Vulkan Spec</a>: The Vulkan specification</li>
      <li><a href="https://github.com/SaschaWillems/Vulkan">Vulkan Examples</a>: A collection of demos featuring various Vulkan features in a concise and understandable manner</li>
      <li><a href="https://github.com/vinjn/awesome-vulkan">Awesome Vulkan</a>: A compendium of Vulkan projects, articles, tutorials, and more</li>
      <li><a href="https://www.jeremyong.com/c++/graphics/gpu/vulkan/2018/11/22/vulkan-synchronization-primer.html">Vulkan Synchronization Primer</a>: Self-authored short two-part primer for when you want to delve into the topic of Vulkan synchronization more</li>
    </ul>
  </li>
  <li>Consider subscribing or joining the following Vulkan communities
    <ul>
      <li><a href="https://www.reddit.com/r/vulkan">Vulkan Subreddit</a></li>
      <li><a href="https://discord.gg/JyJDbyH">Vulkan Discord</a></li>
    </ul>
  </li>
</ul>

<h1 id="vulkan-mental-model">Vulkan Mental Model</h1>

<h4 id="shaders">Shaders</h4>

<p>Before starting any tutorials, take a look at the following vertex shader.</p>

<div class="language-glsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#version 450
</span>
<span class="c1">// Rather contrived shader for illustrative purposes</span>

<span class="k">layout</span> <span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="k">in</span> <span class="kt">vec3</span> <span class="n">position</span><span class="p">;</span>

<span class="k">layout</span> <span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="k">in</span> <span class="kt">vec2</span> <span class="n">uv</span><span class="p">;</span>

<span class="k">layout</span> <span class="p">(</span><span class="n">binding</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">set</span> <span class="o">=</span> <span class="mi">3</span><span class="p">)</span> <span class="k">uniform</span> <span class="n">UBO</span>
<span class="p">{</span>
  <span class="kt">mat4</span> <span class="n">projection</span><span class="p">;</span>
<span class="p">}</span> <span class="n">ubo</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>

<span class="k">layout</span> <span class="p">(</span><span class="n">binding</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">set</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="k">uniform</span> <span class="kt">sampler2D</span> <span class="n">noise_textures</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>

<span class="k">layout</span> <span class="p">(</span><span class="n">binding</span> <span class="o">=</span> <span class="mi">2</span><span class="p">)</span> <span class="n">buffer</span> <span class="n">Buffer</span>
<span class="p">{</span>
  <span class="kt">mat4</span> <span class="n">something</span><span class="p">;</span>
<span class="p">}</span> <span class="n">buffer</span><span class="p">;</span>

<span class="k">layout</span> <span class="p">(</span><span class="n">push_constant</span><span class="p">)</span> <span class="k">uniform</span> <span class="n">Camera</span> <span class="p">{</span>
  <span class="kt">vec2</span> <span class="n">pos</span><span class="p">;</span>
<span class="p">}</span> <span class="n">camera</span><span class="p">;</span>

<span class="k">layout</span> <span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="k">out</span> <span class="kt">vec3</span> <span class="n">out_uv</span><span class="p">;</span>

<span class="k">out</span> <span class="nb">gl_PerVertex</span>
<span class="p">{</span>
  <span class="kt">vec4</span> <span class="nb">gl_Position</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="c1">// shader code</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Specifically, pay attention to the various layout options you have at your disposal. There are <code class="language-plaintext highlighter-rouge">location</code> specifiers (you’ll recognize the inputs to the vertex shader corresponding to vertex buffers and vertex attributes), the <code class="language-plaintext highlighter-rouge">binding</code> and <code class="language-plaintext highlighter-rouge">set</code> specifiers, and the <code class="language-plaintext highlighter-rouge">push_constant</code>. Also notice that some of these layout variables refer to arrays of data (aka 3 <code class="language-plaintext highlighter-rouge">noise_textures</code> samplers and 4 <code class="language-plaintext highlighter-rouge">uniform</code> buffer objects). One of the more confusing aspects of Vulkan to the uninitiated is what these all mean, and which Vulkan calls correspond to which. In general, when you learn a new API call or object related to descriptor binding (i.e. <a href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/VkWriteDescriptorSet.html">VkWriteDescriptorSet</a>), a parameter passed will correspond to one of those <code class="language-plaintext highlighter-rouge">binding</code>, <code class="language-plaintext highlighter-rouge">set</code>, or array index numbers. The thing that you bind to that location will be specified as a <code class="language-plaintext highlighter-rouge">buffer</code>, <code class="language-plaintext highlighter-rouge">uniform</code>, <code class="language-plaintext highlighter-rouge">sampler2D</code>, <code class="language-plaintext highlighter-rouge">sampler2Darray</code>, or what have you depending on the Vulkan object you specify. Existing documentation does <strong>NOT</strong> do a great job of mapping the API parameters/objects to the shader you will ultimately write, so just keep this in mind and cross reference tutorial code with the tutorial shaders. Because tutorials often use 0-indexed everything, you might inadvertently conflate one parameter’s value with the value in the shader. After you get something working, try experimenting to make sure you got it. As another tip, when you read the documentation, read words like “binding” and “set” rather literally and consider how you would access them in a shader as a way of “grounding” your understanding.</p>

<p>Later on, when you write your engine, game, demo, or whatever, you’ll have a lot of flexibility in how to bind data to shaders, and also how to provision and allocate this memory. As I mentioned before, there are tradeoffs to the various approaches, so don’t be afraid do try something new or reimagine how it should work for your workload. Even if you’re wrong, the experience doing so will be useful!</p>

<h4 id="render-passes-and-pipelines">Render passes and pipelines</h4>

<p>Another important concept to understand is the song and dance related to render passes and pipelines. These types of objects were very common to have abstractions for in game and graphics engines already. Chances are, the abstraction you’re already used to matches the Vulkan one pretty well, but don’t make that assumption. A pipeline here is literally the graphics pipeline. A full specification of all the various stages of the graphics pipeline (<a href="https://fgiesen.wordpress.com/2011/07/09/a-trip-through-the-graphics-pipeline-2011-index">link again</a>) like what shaders you want to use, what the vertex input format is, if depth testing is enabled, what blend operation you want, etc. The pipeline <em>depends on</em> the render pass because the pipeline needs to know what the required input and output attachments are. Render passes in Vulkan support a handy feature called <code class="language-plaintext highlighter-rouge">subpasses</code> which allow you to specify in advance multiple stages of rendering that have some set of dependencies amongst each other. This will allow the GPU to schedule non-dependent subpasses independently for some transparent speed-gains. In general, the entire configuration of render passes you provide, their subpasses, and the pipelines (read. pipeline states) that you bind during the execution of each render subpass dictates however all the draws in your frame will occur.</p>

<p>As an aside, a framebuffer is a collection of attachments that a render pass emits to (could be a color attachment, color + depth, multiple color attachments etc). A framebuffer may contain the final swapchain image you want to present, but this doesn’t have to be the case. You would use this if you wanted to implement deferred rendering for example, or any rendering technique that has multiple render passes (or if you wanted to emit data to a surface that wasn’t just the presented surface). If you are a graphics engineer, you likely know this already, but it can be helpful to know that Vulkan is pretty literal about its definitions.</p>

<h4 id="memory">Memory</h4>

<p>In C or C++, you have <code class="language-plaintext highlighter-rouge">malloc</code> which you can use to get a block of memory. Vulkan’s memory model is a bit more complicated because there are more types of memory (device visible, coherent, local, etc). Beyond that though, you recite an incantation and now have a block of memory. The type you choose depends on whether you expect the memory to be written to each frame, if you need to to be GPU writeable, etc. Afterwards, to use said memory, you need to associate it with a buffer or image (or any number of either). For the buffers and images, you need to put one final layer of buffer views or image views on top to be usable in a shader. At each one of these layers of abstraction, you have options! You can make a separate memory allocation for each buffer and image, and a corresponding view for each one (the least efficient way), or you could go on the other extreme and back your entire engine with a single memory allocation and heavy use of memory aliasing with views out the wazoo referencing this single region (hint, in practice people strive to this extreme but end up to the left). Just as you are expected to <code class="language-plaintext highlighter-rouge">free</code> code you have allocated with <code class="language-plaintext highlighter-rouge">malloc</code>, you must also reclaim memory in Vulkan. Of course, you also need to make sure you aren’t using it anymore, and I’ll talk about ways you can address this soon. Pay attention to the layout alignment rules, as messing up may land you in difficult to debug situations.</p>

<h4 id="synchronization">Synchronization</h4>

<p>The topic Vulkan beginners likely dread the most. If you’ve already coded multithreaded code in C or C++, don’t sweat this too much (pay attention to it obviously, but you already know most of the concepts you need). Treat the GPU as a separate thread of execution conceptually. Treat memory you allocate as shared. Don’t write to that memory if it’s being used. Don’t free that memory if it’s being used. You can do this in a very heavy handed way if you like (literally flush the graphics queue so you know nothing is in use at all when you do your thing). Alternatively, you can come up with a double buffering scheme if you want, or inject explicit fences so you know exactly when a particular command you issued to the GPU has finished. If you have different GPU commands that depend on each other (e.g. a compute job is depending on the output of a render job) use semaphores. If there are dependencies you can articulate with render subpasses, do so. For controlling access to memory when they change ownership, layouts, or visibility, use a memory barrier. In general though, just imagine the GPU is a really fat thread that’s sharing memory with you and that you need to play nice (and stretching this one step further, the various graphics, transfer, and compute queues can be thought of as separate “threads” within the GPU). Prior to Vulkan, the driver did a whole lot of ref-counting to hide this from you, but now you get to be the boss! A really nice trick for reclaiming resources, for example, is to just wait a frame or so (at which point you’re drawing with all the newly allocated things). But there are a lot of approaches just as there are plenty of ways of skinning a cat in C++ multithreading land.</p>

<h1 id="reading-the-vulkan-tutorial-or-api-without-secrets">Reading the <a href="https://vulkan-tutorial.com">Vulkan Tutorial</a> or <a href="https://software.intel.com/en-us/articles/api-without-secrets-introduction-to-vulkan-part-1">API without Secrets</a></h1>

<p>My recommendation is the following:</p>

<ol>
  <li>Don’t be afraid to copy-paste.</li>
  <li>Don’t try to get too clever and define your own functions, classes, etc.</li>
  <li>Read the spec as you introduce new concepts from the tutorial.</li>
</ol>

<p>My reasoning is that mindless typing doesn’t actually help you. You shouldn’t be trying to memorize the API since after using it “for real” you will pick that up surprisingly quickly once you get your bearings around the concepts. Also, because you are a bit new to the API, even if you <em>think</em> you know what abstractions you’ll need, you may be mistaken and shuffling around code is not a great usage of time. You <em>should</em>, however, be trying to learn concepts (image layout transitions, command execution, memory allocation, etc). You’re also trying to get the gist of a Vulkan application, while noting that there are substantial differences between what you ultimately write, and the Vulkan Tutorial. Some key points to keep in mind:</p>

<ul>
  <li>The tutorial prerecords commands for each framebuffer in the swapchain and just replays them every frame. This is a highly unrealistic workflow as most applications need to draw things dynamically</li>
  <li>The tutorial has a very linear order to what Vulkan objects get created but in some cases, this is not necessary. Try to take notes of the timeline as a tree so you understand where there are actual dependencies and where the author just happened to do a thing first</li>
  <li>The tutorial uses the C API and I don’t like the C API (subjective of course ^^)</li>
</ul>

<p>As for choosing between the these two tutorials, they are both well written although I find the Intel one slightly more comprehensive. It also makes you do a bit more work so if you’re looking for a faster path to just getting the gist and then striking off on your own, the former tutorial may be more up your alley.</p>

<h1 id="doing-your-own-thing">Doing your own thing</h1>

<p>Supposing you’ve gone through and finished the Vulkan tutorial, I recommend trying to implement your own renderer. This is a good time to experiment with pipeline derivatives, secondary command buffers, alternative memory layout schemes, push constants, using the compute queue, and more. For allocating/freeing memory, I highly recommend the open sourced memory allocator from AMD (<a href="https://github.com/GPUOpen-LibrariesAndSDKs/VulkanMemoryAllocator">link</a>). It might feel like “cheating” but you’ll find that even with this allocator, there are plenty of knobs to turn and levers to pull to tune your game or engine as you see fit. I do recommend at some point trying to write a simpler allocator for learning purposes, and you will find that it is essentially an exercise in writing <code class="language-plaintext highlighter-rouge">malloc</code>.</p>

<p>As you try to use a feature, you will likely find an appropriate example in Sascha Willem’s excellent <a href="https://github.com/SaschaWillems/Vulkan">Vulkan examples repo</a>. Keep in mind that the project organization places shaders in a <code class="language-plaintext highlighter-rouge">data</code> subfolder from the root of the repository when perusing the examples.</p>

<p>Try to be more aggressive than you even think is possible in terms of draw call minimization. For example, lots of indie games that I see could likely be drawn entirely with a couple draw calls and careful bookkeeping. Once you start to grasp how this is possible with the resources at your disposal, stop and congratulate yourself! You’ve started to grok Vulkan B).</p>

<h1 id="conclusion">Conclusion</h1>

<p>Hopefully, this post helped clear up some misconceptions and gave helpful pointers in making efficient and effective forward progress in your Vulkan-learning process. Feel free to tweet me or email if you have any feedback or suggestions!</p>


</div>
    </div>
  </div>
</body>

</html>