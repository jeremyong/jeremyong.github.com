<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Best Practices for Authoring Generic Data Structures &#8211; ninepoints</title>
  <meta name="viewport" content="width=device-width">
  <meta name="description"
    content="C++, graphics, deep learning, multithreading, Vulkan, OpenGL, DirectX, Math, compilers, and more">
  
  <meta name="robots" content="all">
  <meta name="author" content="Jeremy Ong">
  <link rel="canonical" href="https://jeremyong.com/c++/graphics/2018/11/17/best-practices-for-authoring-generic-data-structures/">
  <link rel="alternate" type="application/rss+xml" title="RSS Feed for ninepoints" href="/%20/feed.xml" />

  <!-- Custom CSS -->
  <link rel="stylesheet" href="/css/main.css" type="text/css">

  <!-- Fonts -->
  
  <link href="https:////maxcdn.bootstrapcdn.com/font-awesome/latest/css/font-awesome.min.css" rel="stylesheet">
  

  
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css"
    integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">

  <!-- The loading of KaTeX is deferred to speed up page rendering -->
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js"
    integrity="sha384-g7c+Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI+sEnkvrMWph2EDg4"
    crossorigin="anonymous"></script>

  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js"
    integrity="sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC+Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa" crossorigin="anonymous"
    onload="renderMathInElement(document.body);"></script>
  

  <!-- Icons -->
  <link rel="apple-touch-icon" sizes="57x57" href="/apple-touch-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/apple-touch-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/apple-touch-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/apple-touch-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/apple-touch-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/apple-touch-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/apple-touch-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/apple-touch-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon-180x180.png">
  <link rel="icon" type="image/png" href="/favicon-192x192.png' sizes=" 192x192">
  <link rel="icon" type="image/png" href="/favicon-160x160.png' sizes=" 160x160">
  <link rel="icon" type="image/png" href="/favicon-96x96.png' sizes=" 96x96">
  <link rel="icon" type="image/png" href="/favicon-16x16.png' sizes=" 16x16">
  <link rel="icon" type="image/png" href="/favicon-32x32.png' sizes=" 32x32">
  <link rel="shortcut icon" href="/favicon.ico">

  <script>
    if (window.navigator && navigator.serviceWorker) {
      navigator.serviceWorker.getRegistrations()
        .then(function (registrations) {
          for (let registration of registrations) {
            registration.unregister();
          }
        });
    }
  </script>
  
  <script async type="text/javascript">
    (function (i, s, o, g, r, a, m) {
      i['GoogleAnalyticsObject'] = r; i[r] = i[r] || function () {
        (i[r].q = i[r].q || []).push(arguments)
      }, i[r].l = 1 * new Date(); a = s.createElement(o),
        m = s.getElementsByTagName(o)[0]; a.async = 1; a.src = g; m.parentNode.insertBefore(a, m)
    })(window, document, 'script', 'https://www.google-analytics.com/analytics.js', 'ga');
    ga('create', 'UA-10576233-1', 'auto');
    ga('send', 'pageview');
  </script>
  
</head>

<body>
  <div class="content">
    <nav class="nav">
  
  

  <ul class="wrap">
    <li>
      <a href="/" class="site-title">Home</a>
    </li>
    

    

    <li>
      
      <a href="/about/">About</a>
      
    </li>


    

    

    <li>
      
    </li>


    
    <li>
      <a class="fa fa-github" href="https://github.com/jeremyong"></a>
    </li>
    <li>
      <a class="fa fa-twitter" href="https://twitter.com/m_ninepoints"></a>
    </li>
    <li>
      <a class="fa fa-linkedin" href="https://www.linkedin.com/in/jeremycong"></a>
    </li>
  </ul>
</nav>

    <div class="wrap">
      <div class="front-matter">
  <div class="wrap">
    <h1>Best Practices for Authoring Generic Data Structures</h1>
    <h2></h2>
    <div class="byline">
      <p>17 November 2018</p>
    </div>
    <div class='clear'></div>
  </div>
</div>

<div class="wrap article">
  <p>This is a collection of ideas I’ve developed over the years that have resulted in higher
quality and more ergonomic code. In this article, I’m going to say the caveat once (right now)
that you should always code and architect for your particular workflow, and these ideas may or may not
apply. Henceforth, I’m going to be prescriptive about what I think a good set of patterns for,
and do my best to provide the rationale. I’m not going to talk about actual data structures
themselves, but instead about design principles and coding practices that I think apply to
all data structures as it relates to C++. In the code examples, pretend I did all the <code class="language-plaintext highlighter-rouge">constexpr</code>,
<code class="language-plaintext highlighter-rouge">[[nodiscard]]</code>, <code class="language-plaintext highlighter-rouge">noexcept</code>, and any other aspects of the attribute and modifier zoo properly
(omitted for brevity).</p>

<h2 id="moving-away-from-the-standard-way">Moving away from the “standard” way</h2>

<p>For the sake of example throughout this article, we’ll talk about authoring the most primitive
of useful data structures (the quadratically resizing array I’ll just call <code class="language-plaintext highlighter-rouge">vector</code> here).
If I asked most people to sketch the implementation, they’d probably come up with something that
rhymes with the following:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">vector</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="c1">// A bunch of constructors handling various types of initialization, moves, and copies</span>
    <span class="c1">// A destructor that invokes `delete` on `data_` if non-null</span>
    <span class="c1">// An iterator type, and `begin`, `end`, `rbegin`, `rend`, and their const equivalents</span>
    <span class="c1">// Methods for mutating the `vector` like `push_back`, `emplace_back`, `clear`, etc.</span>
    <span class="c1">// Operators and accessors for reading and writing to constituent data</span>

<span class="nl">private:</span>
    <span class="kt">void</span> <span class="n">grow</span><span class="p">();</span> <span class="c1">// Invoked when the size_ is about to grow beyond the capacity_</span>

    <span class="n">T</span><span class="o">*</span> <span class="n">data_</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
    <span class="kt">size_t</span> <span class="n">size_</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">size_t</span> <span class="n">capacity_</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<p>This is not a bad place to start; after all, most standard containers you use will resemble
this style of implementation. And I would contend that often times, we can improve on this
a good deal.</p>

<h2 id="interface-weaknesses-of-the-vanilla-approach">Interface weaknesses of the vanilla approach</h2>

<p>The primary gripe I have with data structures authored as above is the template parameter <code class="language-plaintext highlighter-rouge">T</code>.
On the surface, this seems necessary. The data structure should know how <code class="language-plaintext highlighter-rouge">T</code> is constructed,
moved, and destructed, right? After all, such operations on <code class="language-plaintext highlighter-rouge">T</code> all need to happen over the
lifetime of the data structure. Furthermore, <code class="language-plaintext highlighter-rouge">T</code> comes with information about the size and
alignment requirements for allocating memory to store it.</p>

<p>To understand why this might be a problem, consider the issue of writing a common interface
to, say, a rendering backend. You want to provide a class that contains data structures that
hold information like shader handles, pipeline objects, buffer handles, and texture data.
This interface may be implemented numerous times for this project, to provide an OpenGL, Vulkan,
Metal, and D3D backend (possibly across multiple versions of each). Furthermore, for various
types of data, the alignment or size requirements may not even be known until runtime. Many
buffer types have extended alignment restrictions that must be queried by the GPU.</p>

<p>For this type of interface, using the naive <code class="language-plaintext highlighter-rouge">vector</code> class implemented above, we cannot house it
in the common interface layer. It needs to be duplicated within each backend implementation
of the renderer. Furthermore, we may need to choose a very pessimistic alignment requirement
to ensure that things work portably. All this means that we both waste memory, and also will
have a tough time sharing common code that needs to operate on these data structures. For
example, we’d love to have a common set of functions for managing the lifetimes of each resource
type, and tracking memory budgets and usage.</p>

<h2 id="an-alternative-design">An alternative design</h2>

<p>The problem, in my opinion, is that there is too much internal coupling with this design. The
data structure simultaneously manages both the memory and data structure algorithms <em>and</em> the
lifecycle operations of the type <code class="language-plaintext highlighter-rouge">T</code>.</p>

<p>This is where my own code takes a sharp left turn from other generic code I’ve seen. I believe
that data structures should in fact be provided as two separate classes, the <em>storage</em> class,
and the <em>view</em> class. The <em>storage</em> class should only be concerned with the size and alignment
restrictions of its internals, as well as its policy for when data needs to move around or
allocate. The <em>view</em> class should be a thin type-safe adaptor that can access the data without
the need for excessive casting.</p>

<p>Here’s an example, of what this might look like:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">vector_storage</span><span class="p">;</span> <span class="c1">// Forward declaration of non-templatized vector</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">vector_view</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">vector_view</span><span class="p">(</span><span class="n">vector_storage</span><span class="o">&amp;</span> <span class="n">v</span><span class="p">)</span> <span class="o">:</span> <span class="n">vector_storage_</span><span class="p">{</span><span class="n">v</span><span class="p">}</span> <span class="p">{}</span>

    <span class="c1">// An iterator type, and `begin`, `end`, `rbegin`, `rend`, and their const equivalents</span>
    <span class="c1">// Methods for mutating the `vector` like `push_back`, `emplace_back`, `clear`, etc.</span>
    <span class="c1">// Operators and accessors for reading and writing to constituent data</span>
<span class="nl">private:</span>
    <span class="n">vector_storage</span> <span class="n">vector_storage_</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">vector_storage</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">vector</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">element_size</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">alignment</span><span class="p">);</span>

    <span class="c1">// template member functions for push_back, iterators, etc.</span>

    <span class="c1">// For example:</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
    <span class="kt">void</span> <span class="n">push_back</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">value</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">static_assert</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">T</span><span class="p">)</span> <span class="o">==</span> <span class="n">element_size_</span><span class="p">,</span> <span class="s">"Type size mismatch"</span><span class="p">);</span>
        <span class="k">static_assert</span><span class="p">(</span><span class="k">alignof</span><span class="p">(</span><span class="n">T</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">alignment_</span><span class="p">,</span> <span class="s">"Alignment restriction violation"</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">size_</span> <span class="o">==</span> <span class="n">capacity_</span><span class="p">)</span> <span class="n">grow</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">();</span>
        <span class="o">*</span><span class="p">(</span><span class="n">begin</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">()</span> <span class="o">+</span> <span class="n">size_</span><span class="p">)</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">value</span><span class="p">);</span>
        <span class="o">++</span><span class="n">size_</span><span class="p">;</span>
    <span class="p">}</span>

<span class="nl">private:</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="n">T</span><span class="p">&gt;</span>
    <span class="kt">void</span> <span class="n">grow</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">capacity_</span> <span class="o">*=</span> <span class="mi">2</span><span class="p">;</span>
        <span class="kt">void</span><span class="o">*</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">data_</span><span class="p">;</span>
        <span class="n">_data</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">malloc</span><span class="p">(</span><span class="n">capacity_</span> <span class="o">*</span> <span class="n">element_size_</span><span class="p">);</span>
        <span class="k">if</span> <span class="k">constexpr</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">is_trivially_copyable</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">memcpy</span><span class="p">(</span><span class="n">_data</span><span class="p">,</span> <span class="n">temp</span><span class="p">,</span> <span class="n">size_</span> <span class="o">*</span> <span class="n">element_size_</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">else</span>
        <span class="p">{</span>
            <span class="c1">// Loop through old memory and for each element_size_ block,</span>
            <span class="c1">// perform a cast and move to the new location</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="kt">void</span><span class="o">*</span> <span class="n">data_</span><span class="p">;</span>
    <span class="kt">size_t</span> <span class="n">size_</span><span class="p">;</span>
    <span class="kt">size_t</span> <span class="n">capacity_</span><span class="p">;</span>
    <span class="kt">size_t</span> <span class="n">element_size_</span><span class="p">;</span>
    <span class="kt">size_t</span> <span class="n">alignment_</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<p>Hopefully, this stub code is enough to get the gist of the idea. We now have two classes, one
templatized, one not. The one that isn’t templatized is concerned only with the actual
storage algorithm, but defined templatized member functions so it can essentially transmute
itself as necessary. Now, with this interface, we can have a common class interface define
the structure directly, with common functions that operate on it. The various platform
specific implementations can create a “view” to operate on the structure in a type-safe manner.</p>

<p>Note that we an define another class like so:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">vector</span> <span class="o">:</span> <span class="k">public</span> <span class="n">vector_view</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">vector</span><span class="p">()</span>
        <span class="o">:</span> <span class="n">vector_storage_</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">T</span><span class="p">),</span> <span class="k">alignof</span><span class="p">(</span><span class="n">T</span><span class="p">))</span>
        <span class="p">,</span> <span class="n">vector_view</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">vector_storage_</span><span class="p">)</span>
    <span class="p">{}</span>

<span class="nl">private:</span>
    <span class="n">vector_storage</span> <span class="n">vector_storage_</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<p>and this completely recovers the original semantics of the vector! However, now, we have
several significant advantages. For the price of the storage space for the element size
and alignment requirement, we have an adaptor type we can use to alias memory if necessary.
We can handle runtime element sizing and alignment requirements. We can reuse more generic
code (even if different platform requirements store different types of data in the structure).
And we always have the fully type-safe version to fall back on if necessary.</p>

<h2 id="views-for-days">Views for days</h2>

<p>There is another strength to this approach which I haven’t touched on yet.
The type-safe <code class="language-plaintext highlighter-rouge">view</code> adaptor can be templatized on the <code class="language-plaintext highlighter-rouge">storage</code> class itself. This means
that we can have a single <code class="language-plaintext highlighter-rouge">view</code> adaptor for an entire class of data structures. For example,
all traversable, random access data structures could be wrapped by the same view template.
Similarly, we can provide a single uniform view for all associative containers. Looking
forward at C++ concepts, each view template accepts a data structure constrained to a
particular concept.</p>

<p>The possibilities of this are myriad. Here are some ideas for view-types you could provide:</p>

<ul>
  <li>Want your container to be threadsafe? Keep the storage abstraction, but tack on a thread-safe view</li>
  <li>Have a version of the view that is fully instrumented with debugging and tracking that you enable as needed.</li>
  <li>Provide a view that takes a <code class="language-plaintext highlighter-rouge">thread_id</code> as a parameter and enforces that all access to the data
structure originate from that thread.</li>
</ul>

<p>With this approach, you can write such views <em>once</em> for a particular data structure concept and it’s there forever.
That’s generic code at work!</p>

<h2 id="providing-the-allocatorarena">Providing the allocator/arena</h2>

<p>Another point worth making is that all my data structures accept an allocator of some
sort as an argument. Exposing the allocator as a template parameter really doesn’t make
sense, since you want to usually allocate the memory in a specific <em>instance</em> of the
allocator. As I generally work with pretty performance sensitive code, this is a must,
and I rarely ever rely on the system malloc (although I have an allocator that passes
through to malloc occassionally for convenience in testing). This completely bypasses
the need for polymorphic allocators, which are needed to permit type comparisons between
data structures that would otherwise by the same except for the allocator type. To me,
this is a hot mess that I think is worth avoiding entirely in your own code.</p>

<h2 id="yet-more-opinions">Yet more opinions</h2>

<p>Consider making your default views and type-safe wrappers fail when passed a non-trivially-copyable
template parameter if performance is crucial. Usually, if you’re writing a custom
data structure anyways, this is because you have particular needs that aren’t met
by the out-of-box containers. As such, if you’re storing rich objects that have
fancy moves and resource management semantics, you’re likely not doing yourself a
favor. Enforcing various type traits, size/alignment restrictions, etc at the view
level at compile-time is <em>great</em> for forcing the user to design the data layout
correctly upfront.</p>

<h2 id="conclusion">Conclusion</h2>

<p>TL;DR For writing high-performance generic data structures</p>

<ul>
  <li>Separate type-specific access and mutation code to a separate class for forwards the type to
a storage class. The storage class has templatized member functions, but is itself non-templatized.</li>
  <li>Provide a single view for each broad class of data structures that behave with similar semantics.</li>
  <li>Provide different view types to handle differences in access patterns (thread safety, logging, etc).</li>
  <li>Always accept an allocator as an argument with an interface exposed in your code somewhere. Don’t
bake it into your type-signature.</li>
  <li>Enforce better defaults for encouraging data-oriented SoA design and hide less-performant patterns
behind more verbose interfaces.</li>
</ul>

</div>
    </div>
  </div>
</body>

</html>