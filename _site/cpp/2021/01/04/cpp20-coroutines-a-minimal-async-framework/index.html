<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>C++20 Coroutines: sketching a minimal async framework &#8211; ninepoints</title>
  <meta name="viewport" content="width=device-width">
  <meta name="description"
    content="C++, graphics, deep learning, multithreading, Vulkan, OpenGL, DirectX, Math, compilers, and more">
  
  <meta name="robots" content="all">
  <meta name="author" content="Jeremy Ong">
  <link rel="canonical" href="https://jeremyong.com/cpp/2021/01/04/cpp20-coroutines-a-minimal-async-framework/">
  <link rel="alternate" type="application/rss+xml" title="RSS Feed for ninepoints" href="/%20/feed.xml" />

  <!-- Custom CSS -->
  <link rel="stylesheet" href="/css/main.css" type="text/css">

  <!-- Fonts -->
  
  <link href="https:////maxcdn.bootstrapcdn.com/font-awesome/latest/css/font-awesome.min.css" rel="stylesheet">
  

  
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css"
    integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">

  <!-- The loading of KaTeX is deferred to speed up page rendering -->
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js"
    integrity="sha384-g7c+Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI+sEnkvrMWph2EDg4"
    crossorigin="anonymous"></script>

  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js"
    integrity="sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC+Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa" crossorigin="anonymous"
    onload="renderMathInElement(document.body);"></script>
  

  <!-- Icons -->
  <link rel="apple-touch-icon" sizes="57x57" href="/apple-touch-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/apple-touch-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/apple-touch-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/apple-touch-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/apple-touch-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/apple-touch-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/apple-touch-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/apple-touch-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon-180x180.png">
  <link rel="icon" type="image/png" href="/favicon-192x192.png' sizes=" 192x192">
  <link rel="icon" type="image/png" href="/favicon-160x160.png' sizes=" 160x160">
  <link rel="icon" type="image/png" href="/favicon-96x96.png' sizes=" 96x96">
  <link rel="icon" type="image/png" href="/favicon-16x16.png' sizes=" 16x16">
  <link rel="icon" type="image/png" href="/favicon-32x32.png' sizes=" 32x32">
  <link rel="shortcut icon" href="/favicon.ico">

  <script>
    if (window.navigator && navigator.serviceWorker) {
      navigator.serviceWorker.getRegistrations()
        .then(function (registrations) {
          for (let registration of registrations) {
            registration.unregister();
          }
        });
    }
  </script>
  
  <script async type="text/javascript">
    (function (i, s, o, g, r, a, m) {
      i['GoogleAnalyticsObject'] = r; i[r] = i[r] || function () {
        (i[r].q = i[r].q || []).push(arguments)
      }, i[r].l = 1 * new Date(); a = s.createElement(o),
        m = s.getElementsByTagName(o)[0]; a.async = 1; a.src = g; m.parentNode.insertBefore(a, m)
    })(window, document, 'script', 'https://www.google-analytics.com/analytics.js', 'ga');
    ga('create', 'UA-10576233-1', 'auto');
    ga('send', 'pageview');
  </script>
  
</head>

<body>
  <div class="content">
    <nav class="nav">
  
  

  <ul class="wrap">
    <li>
      <a href="/" class="site-title">Home</a>
    </li>
    

    

    <li>
      
      <a href="/about/">About</a>
      
    </li>


    

    

    <li>
      
    </li>


    
    <li>
      <a class="fa fa-github" href="https://github.com/jeremyong"></a>
    </li>
    <li>
      <a class="fa fa-twitter" href="https://twitter.com/m_ninepoints"></a>
    </li>
    <li>
      <a class="fa fa-linkedin" href="https://www.linkedin.com/in/jeremycong"></a>
    </li>
  </ul>
</nav>

    <div class="wrap">
      <div class="front-matter">
  <div class="wrap">
    <h1>C++20 Coroutines: sketching a minimal async framework</h1>
    <h2>Lambdas? pfft.</h2>
    <div class="byline">
      <p>04 January 2021</p>
    </div>
    <div class='clear'></div>
  </div>
</div>

<div class="wrap article">
  <p>C++20 ✨coroutines✨ are here! Having spent some 20-odd hours with it, I am by no means an expert on the feature,
but I wanted to jot down my initial impressions and provide some pointers looking to get their feet wet and
try their hand at implementing a coroutine-powered async framework themselves. Spoiler-alert: for engineers that
need to parallelize their code, in particular, engineers used to needing to “jobify” CPU work using lambdas or
function objects, I think coroutines are a godsend in writing expressive code. I have no doubt that they will
be a staple in future AAA game engines, simulation software, and more. What follows below is a pretty
abbreviated tour of coroutines, as I really don’t think you can truly “grok” it without writing a lot of
code yourself, stepping in with a debugger, littering your code with dozens of <code class="language-plaintext highlighter-rouge">printf</code>s, etc. However,
I hope that this post both motivates the use of C++20 coroutines, and also demonstrates that once you
<em>do</em> understand the language facilities for coroutines more, you can do a surprising amount with not a lot
of code.</p>

<h2 id="basic-concepts">Basic Concepts</h2>

<p>This post is going to be overwhelmingly more “applied” in nature, as opposed to delving into the nitty gritty.
That said, we still need to get on the same page about some of the terms you’ll see when working with coroutines
in C++20. Note that to <em>use</em> a coroutine based framework written by someone else, you can actually get away with
surprisingly little knowledge (although there are some gotchas as we will see).</p>

<p>First up is the <em>coroutine</em> itself. A coroutine <em>is a</em> function which can be suspended and resumed (as opposed to
executing from start to finish). As a function, coroutines can be invoked by other coroutines, or by other functions.
As a technicality, the main function itself cannot be a coroutine (you can’t suspend from it). A function becomes
a coroutine the moment you suspend from within its body by invoking <code class="language-plaintext highlighter-rouge">co_await</code> or <code class="language-plaintext highlighter-rouge">co_yield</code>. Note that if you call
a coroutine <code class="language-plaintext highlighter-rouge">c</code> (remember, coroutines are just functions) from a function <code class="language-plaintext highlighter-rouge">f</code>, the function <code class="language-plaintext highlighter-rouge">f</code> is <em>not</em> a coroutine
unless you <code class="language-plaintext highlighter-rouge">co_await</code> the result of <code class="language-plaintext highlighter-rouge">c</code>. In other words, calling a coroutine isn’t sufficient to make the caller a
coroutine. Something must happen in the body of the caller which may cause it to suspend for the caller to be a
coroutine.</p>

<p>The next concept to understand is the <code class="language-plaintext highlighter-rouge">promise_type</code>. A <code class="language-plaintext highlighter-rouge">promise_type</code> is an interface type that can be thought of
as a control object the programmer can use to inject custom behaviour during the lifecycle of a coroutine. Some
sample coroutine lifecycle events are:</p>

<ul>
  <li>An allocation is happening to store the state of a coroutine (activation frame plus any additional data)</li>
  <li>Coroutine is initially created</li>
  <li>Coroutine is about to suspend</li>
  <li>Coroutine has just finished suspending</li>
  <li>Coroutine is completed and is now returning a value</li>
</ul>

<p>Each of these events corresponds to a method you can implement to specify custom behavior.</p>

<p>The final concept to grok when working with coroutines is the <code class="language-plaintext highlighter-rouge">awaitable</code>. An awaitable is anything that can
be the argument of the <code class="language-plaintext highlighter-rouge">co_await</code> unary operator. In order to qualify as an awaitable such that <code class="language-plaintext highlighter-rouge">co_await a</code>
is valid, either, <code class="language-plaintext highlighter-rouge">a</code> has a type with <code class="language-plaintext highlighter-rouge">operator co_await</code> implemented, or <code class="language-plaintext highlighter-rouge">a</code> has a type that implements the
<code class="language-plaintext highlighter-rouge">awaitable</code> trait, or, there is an <code class="language-plaintext highlighter-rouge">await_transform</code> method present on the parent coroutine (remember, an await
happens in the body of a coroutine). Regardless of the mechanism, what is consumed by the <code class="language-plaintext highlighter-rouge">co_await</code> operator
is a object (produced via any of the means above) which possesses the following methods:</p>

<ul>
  <li>An <code class="language-plaintext highlighter-rouge">await_ready</code> that describes if the suspend needs to happen at all (useful for short-circuiting awaits
for which the associated work was already completed)</li>
  <li>An <code class="language-plaintext highlighter-rouge">await_resume</code> which specifies what happens once the await is over</li>
  <li>An <code class="language-plaintext highlighter-rouge">await_suspend</code> which is passed a <code class="language-plaintext highlighter-rouge">coroutine_handle</code> that can be used to resume the parent coroutine later</li>
</ul>

<h2 id="motivating-example">Motivating example</h2>

<p>Suppose we want to read a file from disk, decode it, and then use the results. Furthermore, suppose we want
to run some work in parallel while the file is being read and while the file is being decoded. Here’s what
this code might look like with coroutines.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">task</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">read_file</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">filesystem</span><span class="o">::</span><span class="n">path</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">path</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// File reading operation</span>
  <span class="c1">// Assumes a win32 implementation using overlapped IO, but</span>
  <span class="c1">// this same concept applies to epoll-style file reading as well.</span>
  <span class="n">HANDLE</span> <span class="n">completion_event</span> <span class="o">=</span> <span class="n">win_init_read_file</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>

  <span class="n">co_await</span> <span class="n">completion_event</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">task</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">uint8_t</span><span class="o">&gt;&gt;</span> <span class="n">decode_png</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">data</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Indicate that this function should run as a separate task</span>
  <span class="c1">// on a different thread</span>
  <span class="n">co_await</span> <span class="n">suspend</span><span class="p">();</span>

  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">uint8_t</span><span class="o">&gt;</span> <span class="n">out</span><span class="p">;</span>
  <span class="c1">// PNG decoding code</span>
  <span class="n">co_return</span> <span class="n">out</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">task</span><span class="o">&lt;&gt;</span> <span class="n">some_expensive_function1</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">co_await</span> <span class="n">suspend</span><span class="p">();</span>

  <span class="c1">// Some expensive code</span>
<span class="p">}</span>

<span class="n">task</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">some_expensive_function2</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">co_await</span> <span class="n">suspend</span><span class="p">();</span>

  <span class="c1">// Some expensive code that produces an integer result</span>
  <span class="n">co_return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">task</span><span class="o">&lt;&gt;</span> <span class="n">some_expensive_function3</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">co_await</span> <span class="n">suspend</span><span class="p">();</span>

  <span class="c1">// Some expensive code</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">some_loading_function</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">filesystem</span><span class="o">::</span><span class="n">path</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">path</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">task</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">read_task</span> <span class="o">=</span> <span class="n">read_file</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>

  <span class="c1">// Do two other useful things in parallel while the file</span>
  <span class="c1">// is being read</span>
  <span class="n">task</span><span class="o">&lt;&gt;</span> <span class="n">task1</span> <span class="o">=</span> <span class="n">some_expensive_function1</span><span class="p">();</span>
  <span class="c1">// The second task produces an integral result</span>
  <span class="n">task</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">task2</span> <span class="o">=</span> <span class="n">some_expensive_function2</span><span class="p">();</span>
  
  <span class="c1">// Await the file read and pass the data to the png decoder</span>
  <span class="n">task</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">uint8_t</span><span class="o">&gt;&gt;</span> <span class="n">png_task</span> <span class="o">=</span>
    <span class="n">decode_png</span><span class="p">(</span><span class="n">co_await</span> <span class="n">read_task</span><span class="p">);</span>

  <span class="kt">int</span> <span class="n">task2_result</span> <span class="o">=</span> <span class="n">co_await</span> <span class="n">task2</span><span class="p">;</span>

  <span class="c1">// Do other useful thing while png is decoding using the</span>
  <span class="c1">// result from task2</span>
  <span class="n">some_expensive_function3</span><span class="p">(</span><span class="n">task2_result</span><span class="p">);</span>

  <span class="c1">// Ensure task1 is also finished before proceeding</span>
  <span class="n">co_await</span> <span class="n">task1</span><span class="p">;</span>

  <span class="n">do_something_with_png</span><span class="p">(</span><span class="n">co_await</span> <span class="n">png_task</span><span class="p">);</span>
<span class="p">}</span>

</code></pre></div></div>

<p>When looking at the implementation of <code class="language-plaintext highlighter-rouge">some_loading_function</code>, it’s important to imagine how
difficult this would be to implement with a traditional task-graph style API. Most of these
functions would need to be written as function objects, or we’d have lambdas littered throughout.
However the task graph is implemented, the resulting code would read necessarily <em>non-linearly</em>,
especially in this example where we are essentially forking a function and joining it in a non-trivial
manner. Suffice it to say, I believe the interface shown in the example above will likely be terser
and more readable. So, let’s implement it!</p>

<p>There are <em>three</em> elements that we need to implement to make the above code snippet a reality.</p>

<ol>
  <li>First, we need some way to await for some OS event to signal completion. That is, we need to
wait for something to complete outside of our program.</li>
  <li>Second, we need a way to <em>suspend execution</em> of a function in the current thread in such a way
that this function is resumed automatically in a different thread. This is how we will schedule
multiple tasks to complete in parallel.</li>
  <li>Finally, we need a way to await for work that we’ve enqueued via the suspension routine above.</li>
</ol>

<p>The underlying “substrate” on which our coroutines will run also needs to be defined. Let’s call this
the “Central Task Processor” or CTP for short. It’s interface should be as follows:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">CTP</span> <span class="p">{</span>

<span class="nl">public:</span>
  <span class="c1">// For simplicity, we'll assume a global singleton instance is available</span>
  <span class="k">static</span> <span class="n">CTP</span><span class="o">&amp;</span> <span class="n">instance</span><span class="p">();</span>

  <span class="c1">// The constructor should spawn thread_count threads and begin the run loop of each thread</span>
  <span class="n">CTP</span><span class="p">(</span><span class="kt">int</span> <span class="n">thread_count</span><span class="p">);</span>

  <span class="c1">// When a coroutine is enqueued, the coroutine is passed to one of the CTP threads, and</span>
  <span class="c1">// eventually coroutine.resume() should be invoked when the thread is ready. You can</span>
  <span class="c1">// implement work stealing here to "steal" coroutines on busy threads from idle ones, or</span>
  <span class="c1">// any other load balancing/scheduling scheme of your choice.</span>
  <span class="c1">//</span>
  <span class="c1">// NOTE: This should (obviously) be threadsafe</span>
  <span class="kt">void</span> <span class="n">enqueue</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">coroutine_handle</span><span class="o">&lt;&gt;</span> <span class="n">coroutine</span><span class="p">);</span>
<span class="p">};</span>
</code></pre></div></div>

<p>This simple interface is all we need to indicate that a coroutine that was previously suspended is
now ready to resume. The <code class="language-plaintext highlighter-rouge">CTP</code> will presumably find a thread ready to accept work and resume the coroutine
there, or enqueue it for later. Now, let’s handle the actual coroutine suspension code.</p>

<h2 id="awaiting-an-os-event">Awaiting an OS event</h2>

<p>In order to <code class="language-plaintext highlighter-rouge">co_await</code> for some OS handle that will be completed later, we need to implement <code class="language-plaintext highlighter-rouge">operator co_await</code>,
taking as its sole parameter, the argument to the unary <code class="language-plaintext highlighter-rouge">co_await</code> operator. Thankfully, this
is really quite simple. Again, using windows as an example, we might implement this as follows:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="nc">event_awaiter</span> <span class="p">{</span>
  <span class="n">HANDLE</span> <span class="n">event</span><span class="p">;</span>
  <span class="kt">bool</span> <span class="n">await_ready</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span> <span class="p">{</span>
    <span class="c1">// Check if we need to bother suspending at all by seeing if the</span>
    <span class="c1">// event was already signaled with a non-blocking wait.</span>
    <span class="k">return</span> <span class="n">WaitForSingleObject</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="n">WAIT_OBJECT_0</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kt">void</span> <span class="n">await_suspend</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">coroutine_handle</span><span class="o">&lt;&gt;</span> <span class="n">coroutine</span><span class="p">)</span> <span class="k">const</span> <span class="k">noexcept</span> <span class="p">{</span>
    <span class="c1">// The coroutine handle passed here can be copied elsewhere and resumed</span>
    <span class="c1">// when the event is signaled. Here, we spawn a dedicated thread for</span>
    <span class="c1">// demonstration purposes, but you should have a dedicated low-priority</span>
    <span class="c1">// thread to queue waiting events to.</span>
    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="kr">thread</span><span class="p">{[</span><span class="n">coroutine</span><span class="p">,</span> <span class="n">event</span><span class="p">]()</span> <span class="k">noexcept</span> <span class="p">{</span>
      <span class="n">WaitForSingleObject</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">INFINITE</span><span class="p">);</span>

      <span class="c1">// The CTP will call coroutine.resume() on an available thread now</span>
      <span class="n">CTP</span><span class="o">::</span><span class="n">instance</span><span class="p">().</span><span class="n">enqueue</span><span class="p">(</span><span class="n">coroutine</span><span class="p">);</span>
    <span class="p">}};</span>
    <span class="kr">thread</span><span class="p">.</span><span class="n">detach</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="kt">void</span> <span class="n">await_resume</span><span class="p">()</span> <span class="k">noexcept</span> <span class="p">{</span>
    <span class="c1">// This is called after the coroutine is resumed in the async thread</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Event signaled, resuming on thread %i</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">get_thread_id</span><span class="p">());</span>
  <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div>

<p>To make our event <code class="language-plaintext highlighter-rouge">HANDLE</code> a valid argument to the <code class="language-plaintext highlighter-rouge">co_await</code> operator, we also need to add
an overload for returning the <code class="language-plaintext highlighter-rouge">event_awaiter</code> defined above.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">inline</span> <span class="n">event_awaiter</span> <span class="k">operator</span> <span class="n">co_await</span><span class="p">(</span><span class="n">HANDLE</span> <span class="n">event</span><span class="p">)</span> <span class="k">noexcept</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="p">{</span><span class="n">event</span><span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Now, we can do something like the following:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Retrieve an event that has yet to be signaled</span>
<span class="n">HANDLE</span> <span class="n">event</span> <span class="o">=</span> <span class="n">some_routine</span><span class="p">();</span>

<span class="c1">// Assuming the event is unsignaled, this task will now suspend (await_suspend</span>
<span class="c1">// will be called above). The thread that this code originally ran on is now</span>
<span class="c1">// free to resume a different coroutine enqueued earlier (if any) or simply</span>
<span class="c1">// wait until a task is ready.</span>
<span class="n">co_await</span> <span class="n">event</span><span class="p">;</span>

<span class="c1">// At this point, await_resume() above has been called and we are now running</span>
<span class="c1">// on a potentially different CTP thread.</span>
<span class="n">some_other_routine</span><span class="p">();</span>
</code></pre></div></div>

<p>Neat!</p>

<h2 id="suspend-code-execution">Suspend code execution</h2>

<p>So, the code above lets us suspend a coroutine and resume it when the OS tells
us it’s ready. Let’s now figure out how to suspend a task to resume immediately
on a different CTP thread. Again, we’ll do this using an awaitable.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">inline</span> <span class="k">auto</span> <span class="n">suspend</span><span class="p">()</span> <span class="k">noexcept</span> <span class="p">{</span>
  <span class="k">struct</span> <span class="nc">awaiter</span> <span class="p">{</span>
    <span class="c1">// Unlike the OS event case, there's no case where we suspend and the work</span>
    <span class="c1">// is immediately ready</span>
    <span class="kt">bool</span> <span class="n">await_ready</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span> <span class="p">{</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span> <span class="p">}</span>

    <span class="c1">// Since await_ready() always returns false, when suspend is called, we will</span>
    <span class="c1">// always immediately suspend and call this function (which enqueues the coroutine</span>
    <span class="c1">// for immediate reactivation on a different thread)</span>
    <span class="kt">void</span> <span class="n">await_suspend</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">coroutine_handle</span><span class="o">&lt;&gt;</span> <span class="n">coroutine</span><span class="p">)</span> <span class="k">noexcept</span> <span class="p">{</span>
      <span class="n">CTP</span><span class="o">::</span><span class="n">instance</span><span class="p">().</span><span class="n">enqueue</span><span class="p">(</span><span class="n">coroutine</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">await_resume</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span> <span class="p">{</span>
      <span class="n">printf</span><span class="p">(</span><span class="s">"Suspended task now running on thread $i</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">get_thread_id</span><span class="p">());</span>
    <span class="p">}</span>
  <span class="p">};</span>
  <span class="k">return</span> <span class="n">awaiter</span><span class="p">{};</span>
<span class="p">}</span>
</code></pre></div></div>

<p>This is even more straightforward than the OS event case. In action, this looks like the
following:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Note, we do not yet know what a "task" is. That will be introduced next</span>
<span class="n">task</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">async_routine</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// Suspend this current coroutine and enqueue it to our CTP</span>
  <span class="n">co_await</span> <span class="n">suspend</span><span class="p">();</span>

  <span class="c1">// At this point, we're running on a thread that resumed this coroutine's handle</span>
  <span class="c1">// In this case, we compute some integer and "co_return" it</span>
  <span class="n">co_return</span> <span class="n">some_expensive_thing</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="introducing-the-task">Introducing the “task”</h2>

<p>So far, we’ve implemented two “awaiters” which describe what happens when the coroutine
itself is suspended and resumed. However, this only addresses one side of the story.
Namely, we have not described anywhere in code what should happen to the thread <em>which began
the execution of the suspended coroutine</em>. Take the <code class="language-plaintext highlighter-rouge">async_routine</code> function we wrote
above which produces an <code class="language-plaintext highlighter-rouge">int</code> result asynchronously. How should we define where the result
is written to? Also, how does the caller of <code class="language-plaintext highlighter-rouge">async_routine</code> wait for it to finish? The
answer is with the <code class="language-plaintext highlighter-rouge">promise_type</code> concept which we will wrap in an abstraction called a <code class="language-plaintext highlighter-rouge">task</code>.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc">task</span> <span class="p">{</span>
  <span class="c1">// The return type of a coroutine must contain a nested struct or type alias called `promise_type`</span>
  <span class="k">struct</span> <span class="nc">promise_type</span> <span class="p">{</span>
    <span class="c1">// Keep a coroutine handle referring to the parent coroutine if any. That is, if we</span>
    <span class="c1">// co_await a coroutine within another coroutine, this handle will be used to continue</span>
    <span class="c1">// working from where we left off.</span>
    <span class="n">std</span><span class="o">::</span><span class="n">coroutine_handle</span><span class="o">&lt;&gt;</span> <span class="n">precursor</span><span class="p">;</span>

    <span class="c1">// Place to hold the results produced by the coroutine</span>
    <span class="n">T</span> <span class="n">data</span><span class="p">;</span>

    <span class="c1">// Invoked when we first enter a coroutine. We initialize the precursor handle</span>
    <span class="c1">// with a resume point from where the task is ultimately suspended</span>
    <span class="n">task</span> <span class="n">get_return_object</span><span class="p">()</span> <span class="k">noexcept</span>
    <span class="p">{</span>
      <span class="k">return</span> <span class="p">{</span><span class="n">std</span><span class="o">::</span><span class="n">coroutine_handle</span><span class="o">&lt;</span><span class="n">promise_type</span><span class="o">&gt;::</span><span class="n">from_promise</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">)};</span>
    <span class="p">}</span>

    <span class="c1">// When the caller enters the coroutine, we have the option to suspend immediately.</span>
    <span class="c1">// Let's choose not to do that here</span>
    <span class="n">std</span><span class="o">::</span><span class="n">suspend_never</span> <span class="n">initial_suspend</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span> <span class="p">{</span> <span class="k">return</span> <span class="p">{};</span> <span class="p">}</span>

    <span class="c1">// If an exception was thrown in the coroutine body, we would handle it here</span>
    <span class="kt">void</span> <span class="n">unhandled_exception</span><span class="p">()</span> <span class="p">{}</span>

    <span class="c1">// The coroutine is about to complete (via co_return or reaching the end of the coroutine body).</span>
    <span class="c1">// The awaiter returned here defines what happens next</span>
    <span class="k">auto</span> <span class="n">final_suspend</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span> <span class="p">{</span>
      <span class="k">struct</span> <span class="nc">awaiter</span> <span class="p">{</span>
        <span class="c1">// Return false here to return control to the thread's event loop. Remember that we're</span>
        <span class="c1">// running on some async thread at this point.</span>
        <span class="kt">bool</span> <span class="n">await_ready</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span> <span class="p">{</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span> <span class="p">}</span>

        <span class="kt">void</span> <span class="n">await_resume</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span> <span class="p">{}</span>

        <span class="c1">// Returning a coroutine handle here resumes the coroutine it refers to (needed for</span>
        <span class="c1">// continuation handling). If we wanted, we could instead enqueue that coroutine handle</span>
        <span class="c1">// instead of immediately resuming it by enqueuing it and returning void.</span>
        <span class="n">std</span><span class="o">::</span><span class="n">coroutine_handle</span><span class="o">&lt;&gt;</span> <span class="n">await_suspend</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">coroutine_handle</span><span class="o">&lt;</span><span class="n">promise_type</span><span class="o">&gt;</span> <span class="n">h</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">auto</span> <span class="n">precursor</span> <span class="o">=</span> <span class="n">h</span><span class="p">.</span><span class="n">promise</span><span class="p">().</span><span class="n">precursor</span><span class="p">;</span>
          <span class="k">if</span> <span class="p">(</span><span class="n">precursor</span><span class="p">)</span>
          <span class="p">{</span>
            <span class="k">return</span> <span class="n">precursor</span><span class="p">;</span>
          <span class="p">}</span>
          <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">noop_coroutine</span><span class="p">();</span>
        <span class="p">}</span>
      <span class="p">};</span>
      <span class="k">return</span> <span class="n">awaiter</span><span class="p">{};</span>

      <span class="c1">// When the coroutine co_returns a value, this method is used to publish the result</span>
      <span class="kt">void</span> <span class="n">return_value</span><span class="p">(</span><span class="n">T</span> <span class="n">value</span><span class="p">)</span> <span class="k">noexcept</span>
      <span class="p">{</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">value</span><span class="p">);</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">};</span>

  <span class="c1">// The following methods make our task type conform to the awaitable concept, so we can</span>
  <span class="c1">// co_await for a task to complete</span>

  <span class="kt">bool</span> <span class="n">await_ready</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span> <span class="p">{</span>
    <span class="c1">// No need to suspend if this task has no outstanding work</span>
    <span class="k">return</span> <span class="n">handle</span><span class="p">.</span><span class="n">done</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="n">T</span> <span class="n">await_resume</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span> <span class="p">{</span>
    <span class="c1">// The returned value here is what `co_await our_task` evaluates to</span>
    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">handle</span><span class="p">.</span><span class="n">promise</span><span class="p">().</span><span class="n">data</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="kt">void</span> <span class="n">await_suspend</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">coroutine_handle</span><span class="o">&lt;&gt;</span> <span class="n">coroutine</span><span class="p">)</span> <span class="k">const</span> <span class="k">noexcept</span> <span class="p">{</span>
    <span class="c1">// The coroutine itself is being suspended (async work can beget other async work)</span>
    <span class="c1">// Record the argument as the continuation point when this is resumed later. See</span>
    <span class="c1">// the final_suspend awaiter on the promise_type above for where this gets used</span>
    <span class="n">handle</span><span class="p">.</span><span class="n">promise</span><span class="p">().</span><span class="n">precursor</span> <span class="o">=</span> <span class="n">coroutine</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// This handle is assigned to when the coroutine itself is suspended (see await_suspend above)</span>
  <span class="n">std</span><span class="o">::</span><span class="n">coroutine_handle</span><span class="o">&lt;</span><span class="n">promise_type</span><span class="o">&gt;</span> <span class="n">handle</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<p>OK, there’s understandably a lot to unpack here, so let’s look at a simple function
and establish a chronology for what happens and why.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">task</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">async_routine</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">co_await</span> <span class="n">suspend</span><span class="p">();</span>

  <span class="n">co_return</span> <span class="n">some_expensive_thing</span><span class="p">();</span>
<span class="p">}</span>

<span class="n">task</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">another_async_routine</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// Enqueue 3 invocations of async_routine such that they are all running</span>
  <span class="c1">// in parallel, assuming we have 3 threads available</span>
  <span class="c1">// The current thread enters `async_routine`, then encounters the co_await of the</span>
  <span class="c1">// suspend() above. This yields control back so we can spawn the next async_routine.</span>
  <span class="c1">// In each case, get_return_object is called to construct a task with memory to</span>
  <span class="c1">// store the returned fresult. Furthermore, the coroutine handle to each of these</span>
  <span class="c1">// invocations is stored so that when async_routine suspends internally, this</span>
  <span class="c1">// caller can continue where it left off.</span>
  <span class="n">task</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">t1</span> <span class="o">=</span> <span class="n">async_routine</span><span class="p">();</span>
  <span class="n">task</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">t2</span> <span class="o">=</span> <span class="n">async_routine</span><span class="p">();</span>
  <span class="n">task</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">t3</span> <span class="o">=</span> <span class="n">async_routine</span><span class="p">();</span>

  <span class="c1">// Because t2 is itself an awaitable, a few things happen here. First, we check</span>
  <span class="c1">// in await_ready above if the coroutine handle associated with t2 has already</span>
  <span class="c1">// finalized. If so, we don't need to suspend and can just retrieve the result</span>
  <span class="c1">// directly (internally invokes `return_value`). If t2 hasn't finished yet, we</span>
  <span class="c1">// assign the precursor handle to the current resume point and suspend. When t2</span>
  <span class="c1">// finishes later, its final_suspend will find this precursor and resume here.</span>
  <span class="c1">// Note that it's possible that after this line, we end up running on a different</span>
  <span class="c1">// thread (the thread that finished t2)</span>
  <span class="kt">int</span> <span class="n">r2</span> <span class="o">=</span> <span class="n">co_await</span> <span class="n">t2</span><span class="p">;</span>

  <span class="n">do_something_else</span><span class="p">();</span>

  <span class="c1">// Resume points work in the middle of expressions as well</span>
  <span class="n">co_return</span> <span class="p">((</span><span class="n">co_await</span> <span class="n">t1</span><span class="p">)</span> <span class="o">+</span> <span class="n">r2</span> <span class="o">+</span> <span class="p">(</span><span class="n">co_await</span> <span class="n">t3</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></div></div>

<p>It’s very difficult to describe in exact terms how each “control” method for all
the different awaitables involved coordinate to enable the code above to work. In
general terms though, this is roughly what’s happening:</p>

<ol>
  <li>Every time we enter a coroutine (denoted as a function which returns a <code class="language-plaintext highlighter-rouge">task</code>),
the caller constructs the <code class="language-plaintext highlighter-rouge">task</code> object which contains storage space for data to be
returned by the coroutine (you’ll need to roll a <code class="language-plaintext highlighter-rouge">task&lt;void&gt;</code> specialization as well
if you don’t want that)</li>
  <li>The task also stores a <code class="language-plaintext highlighter-rouge">precursor</code> which refers to the <em>resume point</em>. Initially,
the <code class="language-plaintext highlighter-rouge">precursor</code> is just the point in code directly after the <code class="language-plaintext highlighter-rouge">task</code> construction.</li>
  <li>The task itself can suspend, either by awaiting another task, or by awaiting one of
the two awaitables we made before.</li>
  <li>When a task completes (by working it’s way to the end of its function body or by
encountering a <code class="language-plaintext highlighter-rouge">co_return</code> statement), it immediately resumes the <code class="language-plaintext highlighter-rouge">precursor</code>, which
presumably suspended because of this task.</li>
</ol>

<h2 id="how-do-i-await-a-coroutine-from-something-that-isnt-a-coroutine">How do I await a coroutine from something that isn’t a coroutine?</h2>

<p>This is a fair question. At some point, the entry into a coroutine must come from
something that <em>isn’t</em> a coroutine. After all, the standard dictates that <code class="language-plaintext highlighter-rouge">main</code> must
not be a coroutine. To do this, you’ll need to implement your own <code class="language-plaintext highlighter-rouge">await</code> method which
waits on a <code class="language-plaintext highlighter-rouge">condition_variable</code> or OS event directly. You can store this <code class="language-plaintext highlighter-rouge">condition_variable</code>
on the <code class="language-plaintext highlighter-rouge">task</code> type, then set it in the task’s <code class="language-plaintext highlighter-rouge">final_suspend</code> method for example.</p>

<p>In my codebase, this is referred to as a <code class="language-plaintext highlighter-rouge">jtask</code> (short for “joinable task”) and it is
otherwise identical to the task above except for this additional signaling behavior.</p>

<h2 id="some-implementation-details-i-glossed-over">Some implementation details I glossed over</h2>

<ul>
  <li>You can override <code class="language-plaintext highlighter-rouge">operator new</code> and <code class="language-plaintext highlighter-rouge">operator delete</code> to manage allocations of your task
types yourself. Note that I don’t believe these are guaranteed to be called if the compiler
can elide the allocation altogether, so don’t implement these overrides with visible side-effects</li>
  <li>When suspending a coroutine, remember to ensure that pointers and references used in the
body of the coroutine must have a valid lifetime extended until the coroutine exits. This
is “obvious” but potentially is a pitfall (similar to capturing pointers and references in a lambda)</li>
  <li>If doing this implementation yourself, you can also apply a similar pattern in how we handled
continuations and suspensions here to handle <code class="language-plaintext highlighter-rouge">co_yield</code> expressions.</li>
  <li>You will likely need a <code class="language-plaintext highlighter-rouge">task&lt;void&gt;</code> specialization in order to handle coroutines that execute
but don’t return anything</li>
  <li>My own code has additional state in the <code class="language-plaintext highlighter-rouge">task</code> type to handle things like tracking history
and file and line information (simplifies debugging). Also, the code is instrumented to support
labels in profiling tools like Pix.</li>
</ul>

<h2 id="conclusion">Conclusion</h2>

<p>C++20 coroutines are undoutedly powerful. I didn’t go into all the compiler optimizations
that can kick in to do fancy things like elide heap allocations, but there are significant
advantages to migrating to use coroutines instead of the typical task-graph abstraction.
However, as a powerful abstraction (with extreme amounts of flexibility), C++20 coroutines
are undeniably difficult to learn, at least at first. To get to my current level of proficiency,
I essentially made dozens of example projects with copious amounts of <code class="language-plaintext highlighter-rouge">printf</code> statements
to help me understand the control flow. I highly recommend doing this exercise yourself, as
you may find you would prefer to make different design choices than those offered here.</p>

<p>As I mentioned before, this post isn’t meant to be exhaustive <em>at all</em>, but should hopefully
serve to whet your appetite in terms of what is possible and introduce the general terminology.
My engine (which I can’t publish for reasons at the moment) benefits a great deal from coroutines
with a task and thread pool implementation measuring only several hundreds of lines long!
The real benefit however is in the calling code. After writing this once, I’ve rarely needed
to think much about the mechanics. The only caution needed perhaps is to remember that the
thread a coroutine starts on is not necessarily the same thread that it ends on (as implemented here).
Hopefully, you’ll derive some benefits from C++20 coroutines in the near future also!</p>

</div>
    </div>
  </div>
</body>

</html>